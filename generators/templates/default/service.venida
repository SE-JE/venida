/**
 * Venida Platform
 * Free Open Source Software
 * Autogenerated by SEJE - Digital
 */

namespace {{ serviceNamespace }} {
    /**
     * declare BaseService
     * @object BaseService
     */
    const BaseService = Venida.import('Venida.system.Core.Base.Service');

    /**
     * declare {{ name }} Service
     * @object {{ serviceName }}
     * @type {{ serviceNamespace }}.{{ serviceName }}
     * @description bussiness logic for {{ name }}
     * @extends BaseService
     */
    export class {{ serviceName }} extends BaseService {
        /**
         * Generate pagination meta
         * @param limit max limit per page
         * @param page current page
         * @param offset offset of current page
         * @param total total data
         * @returns object meta
         */
        private generatePaginationMeta(limit: number, page: number, offset: number, total: number): any {
            
            let totalPage = 0;

            if (total > 0) {
                totalPage = Math.ceil(total / limit) || 1;
            }

            let nextPage = page + 1;
            let prevPage = page - 1;

            if (nextPage > totalPage) {
                nextPage = totalPage;
            }

            if (prevPage < 1) {
                prevPage = 1;
            }

            return {
                offset,
                limit,
                total,
                totalPage,
                currentPage: page,
                nextPage,
                prevPage
            };
        }

        /**
         * Paginate data from database
         * @param page current page
         * @param limit limit per page
         * @param search search keyword
         * @returns
         */
        public async paginate(page: number, limit: number, search: string) {

            let model = await this.model('{{ modelName }}');
            let offset = (page - 1) * limit;

            let { data, total } = await model.paginate(offset, limit, search ?? null);
            let meta = this.generatePaginationMeta(limit, page, offset, total);

            return {
                data,
                meta
            };

        }

        /**
         * Find {{ name }} by {{ primaryKey }}
         * @param {{ primaryKey }} {{ primaryKey }} of {{ name }}
         * @returns
         */
        public async findByPrimary({{ primaryKey }}: {{ primaryKeyType }}) {
            let model = await this.model('{{ modelName }}');
            let result = await model.findOne({ {{ primaryKey }} });
            return result;
        }

        /**
         * Create new {{ name }}
         * @param data object of {{ name }} data
         * @returns 
         */
        public async create(data: any) {
            let model = await this.model('{{ modelName }}');
            let acceptedData = {{ acceptedFields }};

            {{ timestamp }}

            // remove unaccepted data
            for (let key in data) {
                if (!acceptedData.includes(key)) {
                    delete data[key];
                }
            }

            let result = await model.insert(data);
            return result;
        }

        /**
         * Update {{ name }} data
         * @param data object of {{ name }} data
         * @returns 
         */
        public async update({{ primaryKey }}: {{ primaryKeyType }}, data: any) {
            let model = await this.model('{{ modelName }}');
            let acceptedData = {{ acceptedFields }};

            {{ timestamp }}

            // remove unaccepted data
            for (let key in data) {
                if (!acceptedData.includes(key)) {
                    delete data[key];
                }
            }

            let result = await model.update({{ primaryKey }}, data);
            return result;
        }

        /**
         * Delete {{ name }} by {{ primaryKey }}
         * @param {{ primaryKey }} {{ primaryKey }} of {{ name }}
         * @returns 
         */
        public async delete({{ primaryKey }}: {{ primaryKeyType }}) {
            let model = await this.model('{{ modelName }}');
            let exist = await model.findOne({ {{ primaryKey }} });

            if (!exist) {
                return false;
            }

            let result = await model.delete({{ primaryKey }});
            return result;
        }

    }
}

module.exports = {{ serviceNamespace }}.{{ serviceName }};